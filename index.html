<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silly Me</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        // Firebase imports - These are still present but not actively used for this version
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Use a debug log level for development
        setLogLevel('debug');

        // Global variables for Firebase configuration
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId;
        let currentPrompt = '';
        let creationHistory = [];

        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        // This listener will ensure Firestore operations only happen after a user is authenticated.
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
            } else {
                await signInAnonymously(auth);
                userId = auth.currentUser.uid;
            }
            document.getElementById('userIdDisplay').textContent = `User ID: ${userId}`;
        });

        if (initialAuthToken) {
            signInWithCustomToken(auth, initialAuthToken).catch((error) => {
                console.error("Firebase custom auth token sign-in failed:", error);
                signInAnonymously(auth).then(() => {
                    userId = auth.currentUser.uid;
                    document.getElementById('userIdDisplay').textContent = `User ID: ${userId}`;
                }).catch((e) => console.error("Anonymous sign-in failed:", e));
            });
        }

        const prompts = {
            'crappy-sketch': 'a scan of a sketch made using a biro on lined paper, it is of a really bad drawn by someone who has never seen this person, bit strange, it\'s not very good, can\'t draw, doodle like, in blue ink on white A4 paper',
            'chalk-doodle': 'A smudged portrait of a person crudely drawn with a stick of white chalk on a dusty, black chalkboard. The lines are not sharp, and some parts are partially erased or smudged, leaving behind a hazy, ghost-like residue. There are visible traces of chalk dust on the bottom.',
            'toddler-painting': 'A simple and slightly lopsided portrait of a person\'s face, created with thick, uneven blobs of primary-colored paint. The colors are mixed messily in places, and the overall impression is one of a hurried, happy, and chaotic art project on a sheet of butcher paper.',
            'bubblegum-sculpture': 'An abstract, lumpy, and slightly glistening portrait bust of a person. It is sculpted from bright pink chewed bubblegum, with some stretched, stringy pieces and a few stray crumbs stuck to it. The entire thing is stuck to a piece of faded cardboard.',
            'macaroni-portrait': 'A portrait of a person constructed entirely from various shapes of dried macaroni and cheese noodles. The noodles are glued on unevenly, some are broken, and the overall form is a very poor representation of the person, glued on a brown piece of construction paper.',
            'crumpled-napkin': 'A hurried, smudged, and dark sketch of a person\'s profile, drawn with a charcoal pencil on a flimsy, slightly off-white paper napkin. The sketch is barely visible through the creases of the napkin and a few coffee stains around the edges.',
            'potato-print': 'A simple, stamp-like portrait of a person created by a series of unevenly inked potato prints. The lines are thick and chunky, and the stamp is applied slightly off-center and with varying pressure, leaving some parts of the print faded.',
            'cross-stitch': 'A low-resolution, pixelated portrait of a person. The image is rendered as a cross-stitch on a piece of beige cloth, with slightly wobbly, uneven stitches. A few loose threads can be seen near the edges, and the whole design is a bit off-center.',
            'ransom-note': 'A portrait of a person where their face and features are made up of cut-out pictures from different magazines. Their eyes, nose, and mouth are all from different people, glued haphazardly onto a piece of cardboard with visible glue residue on the edges.',
        };

        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const downloadButton = document.getElementById('downloadButton');
        const randomButton = document.getElementById('randomButton');
        const historyContainer = document.getElementById('historyContainer');
        const imageModal = document.getElementById('imageModal');
        const enlargedImage = document.getElementById('enlargedImage');
        const closeImageModalButton = document.getElementById('closeImageModalButton');
        
        let currentImage = null;
        let originalImage = null; // Store the original image here

        // --- File Input and Canvas Setup ---
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const aspectRatio = img.width / img.height;
                        canvas.width = 512;
                        canvas.height = 512 / aspectRatio;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        originalImage = canvas.toDataURL('image/png'); // Save the original for future styling
                        currentImage = originalImage;
                        enableButtons(true);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // --- API Call and Image Generation ---
        async function generateImage(prompt) {
            if (!originalImage) {
                showMessage("Please upload an image first.");
                return;
            }
            
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                loadingOverlay.classList.remove('hidden');
                enableButtons(false);
            };
            img.src = originalImage;
            
            const base64ImageData = originalImage.split(',')[1];
            
            // Call the Vercel Serverless Function
            const serverUrl = "/api/generate-image";

            const payload = {
                prompt: prompt,
                imageData: base64ImageData
            };

            let response;
            let retries = 0;
            const maxRetries = 5;
            const initialDelay = 1000;

            while (retries < maxRetries) {
                try {
                    response = await fetch(serverUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) {
                        retries++;
                        const delay = initialDelay * Math.pow(2, retries - 1);
                        await new Promise(res => setTimeout(res, delay));
                        continue;
                    }

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const result = await response.json();
                    const base64Data = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;

                    if (!base64Data) {
                        throw new Error("No image data received from API.");
                    }
                    
                    const newImage = new Image();
                    newImage.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        const aspectRatio = newImage.width / newImage.height;
                        canvas.width = 512;
                        canvas.height = 512 / aspectRatio;
                        ctx.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                        currentImage = canvas.toDataURL('image/png');
                        
                        creationHistory.push({
                            id: Date.now(),
                            image: currentImage,
                            prompt: prompt
                        });
                        renderHistory();

                        loadingOverlay.classList.add('hidden');
                        enableButtons(true);
                    };
                    newImage.src = `data:image/png;base64,${base64Data}`;
                    return;

                } catch (error) {
                    console.error("Error generating image:", error);
                    retries++;
                    const delay = initialDelay * Math.pow(2, retries - 1);
                    await new Promise(res => setTimeout(res, delay));
                }
            }

            loadingOverlay.classList.add('hidden');
            enableButtons(true);
            showMessage("Failed to generate image after multiple retries. Please try again later.");
        }
        
        // --- API call for prompt generation ---
        async function generateRandomPrompt() {
            if (!originalImage) {
                showMessage("Please upload an image first.");
                return;
            }

            randomButton.disabled = true;
            randomButton.textContent = 'Generating Prompt...';
            
            // Call the Vercel Serverless Function
            const serverUrl = "/api/generate-prompt";
            
            const userQuery = "Create a new weird and silly style prompt.";

            const payload = { userQuery };

            let response;
            let retries = 0;
            const maxRetries = 5;
            const initialDelay = 1000;

            while (retries < maxRetries) {
                try {
                    response = await fetch(serverUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) {
                        retries++;
                        const delay = initialDelay * Math.pow(2, retries - 1);
                        await new Promise(res => setTimeout(res, delay));
                        continue;
                    }

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const result = await response.json();
                    const newPrompt = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (!newPrompt) {
                        throw new Error("No prompt received from API.");
                    }
                    
                    randomButton.textContent = 'Random Style';
                    generateImage(newPrompt);
                    return;

                } catch (error) {
                    console.error("Error generating random prompt:", error);
                    retries++;
                    const delay = initialDelay * Math.pow(2, retries - 1);
                    await new Promise(res => setTimeout(res, delay));
                }
            }
            randomButton.textContent = 'Random Style';
            randomButton.disabled = false;
            showMessage("Failed to generate a new prompt. Please try again later.");
        }
        
        // --- History Rendering ---
        function renderHistory() {
            historyContainer.innerHTML = '';
            creationHistory.forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = 'w-24 h-24 overflow-hidden rounded-lg shadow-md cursor-pointer transition-transform hover:scale-105';
                const img = document.createElement('img');
                img.src = item.image;
                img.alt = item.prompt;
                img.className = 'w-full h-full object-cover';
                
                historyItem.addEventListener('click', () => {
                    openImageModal(item.image);
                });

                historyItem.appendChild(img);
                historyContainer.appendChild(historyItem);
            });
        }

        // --- Modal Functionality ---
        function openImageModal(src) {
            enlargedImage.src = src;
            imageModal.classList.remove('hidden');
        }

        closeImageModalButton.addEventListener('click', () => {
            imageModal.classList.add('hidden');
        });


        // --- Button Event Listeners ---
        document.querySelectorAll('.style-button').forEach(button => {
            button.addEventListener('click', () => {
                const style = button.getAttribute('data-style');
                generateImage(prompts[style]);
            });
        });

        document.getElementById('randomButton').addEventListener('click', () => {
            generateRandomPrompt();
        });

        // --- Utility Functions ---
        function enableButtons(enabled) {
            document.querySelectorAll('button').forEach(button => {
                if (button.id !== 'fileInputLabel') {
                    button.disabled = !enabled;
                    button.classList.toggle('opacity-50', !enabled);
                    button.classList.toggle('cursor-not-allowed', !enabled);
                }
            });
            fileInput.disabled = !enabled;
        }

        downloadButton.addEventListener('click', () => {
            if (!currentImage) {
                showMessage("Please generate an image first.");
                return;
            }
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'styled_photo.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // --- Message Box Modal ---
        const modal = document.getElementById('messageModal');
        const modalText = document.getElementById('modalText');
        const closeModalButton = document.getElementById('closeModalButton');

        function showMessage(message) {
            modalText.textContent = message;
            modal.classList.remove('hidden');
        }

        closeModalButton.addEventListener('click', () => {
            modal.classList.add('hidden');
        });
        
    </script>
</head>
<body class="bg-gray-50 text-gray-900 font-[Inter] flex flex-col items-center p-6 min-h-screen">

    <div class="max-w-4xl w-full flex flex-col items-center">
        <h1 class="text-5xl font-bold text-center text-gray-800 mb-2">Silly me!</h1>
        <p class="text-xl text-center text-gray-600 mb-6">Let's go freaky.</p>
        <div id="userIdDisplay" class="text-sm text-gray-500 mb-4 truncate w-full text-center">User ID: ...</div>

        <!-- Main Content Area -->
        <div class="flex flex-col md:flex-row gap-8 w-full">
            
            <!-- Photo Upload & Canvas Section -->
            <div class="flex flex-col items-center flex-1">
                <div class="w-full bg-white rounded-xl shadow-lg p-6 mb-6 relative">
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                    <label for="fileInput" id="fileInputLabel" class="w-full cursor-pointer bg-blue-500 text-white py-3 px-6 rounded-xl text-center text-lg font-bold hover:bg-blue-600 transition-colors duration-200 block mb-4">
                        Upload Photo
                    </label>
                    
                    <div class="relative w-full">
                        <canvas id="imageCanvas" class="w-full h-auto rounded-xl shadow-md border border-gray-200"></canvas>
                        <div id="loadingOverlay" class="hidden absolute inset-0 bg-white bg-opacity-80 flex items-center justify-center rounded-xl">
                            <svg class="animate-spin -ml-1 mr-3 h-12 w-12 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span class="text-gray-700 text-lg">Generating...</span>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex flex-wrap justify-center gap-4 w-full">
                    <button id="downloadButton" class="bg-green-500 text-white font-bold py-3 px-6 rounded-xl transition-transform hover:scale-105 shadow-lg w-full md:w-auto">Download</button>
                </div>
            </div>

            <!-- Style Buttons Section -->
            <div class="flex-1 w-full md:w-auto">
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-2xl font-bold mb-4 text-gray-800">Choose a Style</h2>
                    <div class="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="crappy-sketch">Crappy Sketch</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="chalk-doodle">Chalk Doodle</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="toddler-painting">Toddler Painting</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="bubblegum-sculpture">Bubblegum Sculpture</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="macaroni-portrait">Macaroni Portrait</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="crumpled-napkin">Crumpled Napkin</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="potato-print">Potato Print</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="cross-stitch">Cross-Stitch</button>
                        <button class="style-button bg-gray-100 text-gray-800 p-4 rounded-xl font-bold shadow-sm transition-transform hover:scale-105" data-style="ransom-note">Ransom Note</button>
                        <button id="randomButton" class="bg-blue-500 text-white p-4 rounded-xl font-bold shadow-lg transition-transform hover:scale-105 col-span-2 sm:col-span-2 md:col-span-2 lg:col-span-3">Random Style</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- History Section -->
        <div class="mt-8 w-full max-w-4xl">
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Your Creations</h2>
                <div id="historyContainer" class="flex flex-wrap gap-4 overflow-x-auto p-2">
                    <!-- History items will be rendered here -->
                </div>
            </div>
        </div>

    </div>
    
    <!-- Message Box Modal -->
    <div id="messageModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl p-8 shadow-2xl max-w-sm w-full">
            <p id="modalText" class="text-center text-lg font-medium text-gray-800 mb-6"></p>
            <button id="closeModalButton" class="w-full bg-blue-500 text-white font-bold py-3 rounded-xl transition-colors hover:bg-blue-600">Got it</button>
        </div>
    </div>
    
    <!-- Image Display Modal -->
    <div id="imageModal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
        <div class="relative bg-white rounded-xl p-4 shadow-2xl max-w-lg max-h-[90%] w-full flex flex-col">
            <button id="closeImageModalButton" class="absolute top-2 right-2 text-white bg-red-500 p-2 rounded-full font-bold text-lg leading-none w-8 h-8 flex items-center justify-center">×</button>
            <img id="enlargedImage" src="" alt="Enlarged styled image" class="w-full h-auto object-contain rounded-xl">
        </div>
    </div>

</body>
</html>
